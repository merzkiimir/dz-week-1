/*
	В результате выполнения данной работы слушатель получает много мелких но необходимых
	для дальнейшей работы навыков, поэтому задание построено как последовательность 
	закомментированных блоков, которые требуется последовательно раскомментировать, 
	отвечая  при этом на поставленные вопросы.

	Примерная последовательность действий при отладке проекта:
	1. наберите (исправьте, раскомментируйте нужный фрагмент) исходный текст программы;
	2. откомпилируйте (Build/Compile  ***.cpp или Ctrl+F7)
		Замечание: этот этап явно вызывать необязательно, но полезно для начинающего 
			программиста, т.к. позволяет увидеть ошибки (errors) и предупреждения
			(warnings), возникающие при компиляции данного конкретного файла;
	3. скомпонуйте проект(Build/Build ***.exe или F7)
		Замечание 1: этот этап тоже необязателен, но настоятельно рекомендуем, т.к. 
			позволяет перекомпилировать только измененные файлы и в случае отсутствия
			ошибок всегда полезно посмотреть на выдаваемые компилятором замечания;
		Замечание 2: перед тем, как строить проект, неплохо убедиться  в том, что 
			исполняемый код будет содержать информацию для отладчика - 
				(Build/Configuration Manager.../Configuration - Debug - тип сборки проекта);
	4. поставьте на интересующих Вас строках исходного кода остановы(breakpoints) - F9 или 
		просто кликните левой кнопкой на левой серой полосе окна редактирования; 
	5. запустите программу в режиме отладки 
		(Debug/Start... или  F5);

  Замечание: для перечисленных выше действий приведены комбинации клавиш и соответствующие 
		пункты меню, однако во многих случаях гораздо быстрее то же самое можно сделать с 
		помощью кнопок на Tool Bar, в чем слушатель может преуспеть самостоятельно.

*/

#include  <iostream>		//для использования потоков ввода/вывода
//#include  <intrin.h> //для NOP

int nTwin=1;			//глобальная переменная
namespace TwinSpace{ int nTwin=2;}	//переменная объявлена в
						//пространстве имен - TwinSpace
#define stop do{ } while(0)

//#define	  stop __nop();	//с помощью макроподстановки задаем "пустую" команду.
							//Эта макроподстановка нужна только для того, чтобы
							//можно было поставить на этой строке точку останова.

int main()
{

 //**********************************************************
	//Задание 1. Работа с отладчиком. Базовые типы данных. Выполняя программу по шагам, 
	//следите за значениями переменных и интерпретируйте результат (помните, что 
	//количество байт, отводимых под int, системо-зависимо).
	//Обратите внимание на разную интерпретацию отладчиком signed и unsigned целых типов 
	//данных, а также на внутреннее представление отрицательных целых чисел.

	
	char cByte = 'A';
	cByte    = 0x42; // "B" 66
	cByte    = 66;  // "B" 66
	cByte    = -1;   // -1 '�' (нет -1 для ASCII)

	unsigned char ucByte = 0x41; // "A"
	ucByte   = 'B';// "B"
	ucByte   =	-1; // 255 '�' = 2**8 - 1

	int iInt =  0xffffffff; // -1

	unsigned int uiInt = 0xffffffff; // 4294967295 = 2**32 - 1

	float fFloat = 1.f;  // 1
	double dDouble = 1.; // 1

	// Выполните фрагмент, приведенный далее. В комментариях отразите,
	// что реально заносится в переменную. Объясните разницу между этим 
	// значением и инициализатором.

	double d = 0.1234567890123456789123456789; // 0.12345678901234568
	float  f = 0.1234567890123456789123456789; // 0.123456791

	d	=	1.; // 1
	d	=	0.999999999999999999999999999999999; // 1

	//stop
	
	// В комментариях напишите результат, возвращаемый оператором sizeof для
	// переменной типа wchar_t (ее размер)
	wchar_t cw = L'Ф';
	size_t n = sizeof(cw); // 2 байта

	//stop


// **************************************************************
	//Задание 2a. Неявное приведение типов данных.
	//Объясните разницу результата при выполнении (1) и (2):
	//Покажите явно (напишите в коде) преобразования, которые неявно выполняет компилятор

	iInt=1;
	double dDouble1=iInt/3;		// (i // 3)||(0)
	double dDouble2=iInt/3.;	// (i / 3)||(0.3333333333)


	// Ассоциативность операторов.
	// Синтаксис языка C допускает "цепочечное" присваивание
	// (как в строках (1) и (2)). Посмотрев результаты выполнения строк (1) и (2)
	// (значения переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок 
	// выполения присваиваний при цепочечной записи и объясните результат.
	// Расставте скобки, явно определяющие порядок выполнения, как это сделал бы компилятор.
	// Объясните (в комментариях) предупреждения (warnings) компилятора.

	short sShort;

	dDouble=fFloat=iInt=sShort=cByte=3.3/3;			// (ffloat = 1 ddouble = 1)

	dDouble=(fFloat=(iInt=(sShort=(cByte=(3.3/3)))));
	//Warning conversion from 'double' to 'char':
	//Любое вещественное число по умолчанию воспринимается как double, 
	//поэтому 3.3 рассматривается как double и результат деления тоже double
	//оператор присваивания правоассоциативен, поэтому присвоит переменной типа char(cByte)
	//значение получившееся в результате деления, в результате чего произойдет отбрасывание 
	//вещественной части
	//Warning conversion from 'int' to 'float', possible loss of data:
	//потеря точности может произойти из-за того что во float'e число хранится не в явном виде
	//а как мантисса * основание возведенное в степень 


	cByte=sShort=iInt=fFloat=dDouble=3.3/3;			// (ffloat = 1.1 ddouble = 1.0999999)

	cByte=(sShort=(iInt=(fFloat=(dDouble=(3.3/3)))));
	//Warning conversion from 'double' to 'float':
	//Компилятор предупреждает о возможной потере точности, т.к. величины 
	//мантиссы и порядка для этих типов различаются. float - 4 байта, одинарная точность
	//double - 8 байт, двойная точность


	//ниже Вам дан пример "небрежного" использования неявного приведения типов, что может 
	// привести к нежелательным результатам - объясните (в комментариях), к каким?
	// Напишите явно преобразования, которые неявно выполняет компилятор

	iInt	=	257;
	cByte	=	iInt; // cByte = 1 "\001" (биты не поместившиеся в 1 байтную переменную )

	unsigned char cN1=255, cN2=2, cSum;
	cSum = cN1 + cN2; // cSum = 1 "\001"

	//Сравните предыдущую строчку с приведенной ниже. Объясните (в комментариях),
	//почему в следующей строке не происходит выход за разрядную сетку
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int iSum = cN1+cN2; // isum = 257 а не 1 как в cSum

	//Напишите, почему при сложении одинаковых значений (одинаковых в двоичной системе) 
	// в строках (1) и (2) получаются разные результаты
	// Напишите явно преобразования, которые неявно выполняет компилятор и объясните,
	// что при этом происходит
	char c1=0xff, c2=2;
	unsigned char uc1=0xff, uc2=2;
	int iSum1= c1 + c2;   // 1 (т.к. c1 = -1 (знаковое число); uc1 = 255 (беззнаковое число))
	int iSum2= uc1 + uc2; // 257

	//stop

	
// ***********************************************************
	//Задание 2b. Явное приведение типов данных.
	//Проинтерпретируйте результат (значения переменной dDouble) в строке (3)
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int nTmp=100, nn=3;
	dDouble=3.3 + nTmp / nn; // (3.3 + 100 // 3)
	
	//Получите результат без потери точности с помощью оператора явного
	//приведения типа
//	double dDouble3= 3.3 + nTmp / nn	// (float nTmp=100, nn=3;)


	//stop
